<!doctype html><html><head><meta charset=UTF-8><title>第三学期实训项目展示 - By 广八路东湖村八一路远征队</title><link rel=stylesheet href=https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://cdn.staticfile.org/prism/1.15.0/themes/prism.min.css><link rel=stylesheet href=https://cdn.staticfile.org/KaTeX/0.10.0-rc.1/katex.min.css><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro&amp;family=JetBrains+Mono:ital,wght@0,300;0,400;0,600;0,700;1,400;1,700"><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css><link rel=stylesheet href=https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css><link href=./css/chunk-vendors.4e4765ff.css rel=stylesheet></head><body><div><article id=webslides><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><h1 class="text-landing text-shadow">第三学期实训项目展示</h1><hr><p class=text-intro>By 广八路东湖村八一路远征队</p><p><a href=https://se.jisuanke.com/meshi-sagashi-enseitai class="button ghost" target=_blank><i class="fa fa-github"></i> GitLab</a></p></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h2>队伍成员</h2><ul><li><strong>高安程</strong></li><li><strong>王天朔</strong></li><li><strong>祁盛</strong></li><li><strong>邢玥茗</strong></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><h1 class="text-landing text-shadow">内容组成</h1><ul><li><h4>实现自己的Shell</h4></li><li><h4>高速路网</h4></li><li><h4>黑白棋以及算法优化</h4></li><li><h4>蒜头君抢分作战以及优化</h4></li></ul></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class="content-center text-landing text-shadow"><h2>实现自己的Shell</h2></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h2>要求</h2><ul><li><strong><code>log_t</code></strong><ul><li><code>void log_init(log_t *l)</code> 初始化栈</li><li><code>void log_destroy(log_t* l)</code> 回收内存</li><li><code>void log_push(log_t* l, const char *item)</code> 入栈（将item字符串插入末尾）</li><li><code>char *log_search(log_t* l, const char *prefix)</code> 查找（包含前缀<code>prefix</code>的字符串）</li></ul></li><li><strong><code>shell</code></strong><ul><li><code>prefix</code> 输出当前所在目录</li><li><code>execute</code><ul><li>历史类命令（!# 或 !prefix_str)</li><li>保存指令 分割命令（对于非历史类命令）</li><li>实现内置命令（cd 或 exit 或 ls)</li><li>实现外部指令（DOS指令，先添加./再执行）</li></ul></li></ul></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h2>分工</h2><ul><li><h4>log_t： 祁盛</h4></li><li><h4>Shell：高安程 王天朔 邢玥茗</h4></li><li><h4>调试debug：高安程</h4></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h2>具体实现</h2></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h3>第一部分：<code>log_t</code></h3><p>用链表实现的栈，作用是保存输入的每一条命令以便查找。</p><ul><li><code>void log_init(log_t *l)</code> ; 初始化<code>log_t</code>-&gt; 将<code>l</code>的<code>head</code>设置为<code>NULL</code>。</li><li><code>void log_destroy(log_t* l);</code>销毁<code>log_t</code>——回收所有内存，并将<code>l</code>的<code>head</code>设置为<code>NULL</code></li><li><code>void log_push(log_t* l, const char *item);</code>字符串<code>item</code>插入到一个<code>log_t</code>的末尾</li><li><code>char *log_search(log_t* l, const char *prefix);</code>搜索是否有包含前缀<code>prefix</code>存在的字符串。搜索不到返回NULL</li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h3>第二部分：<code>shell</code></h3><h4><code>prefix</code>函数 -&gt; 输出当前所在目录</h4><ul><li>直接用<code>printf(&quot;%s$ &quot;, cwd)</code>来实现输出以下格式的命令提示符<ul><li><code>/path/to/cwd$</code></li></ul></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h3>execute函数</h3><h4>历史命令类（包含!开头的命令）</h4><img src=./img/shell历史类命令.png alt=shell历史类命令 style="zoom: 67%;"></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h4>分割命令</h4><img src=./img/image-20250715164354788.png alt=image-20250715164354788 style=zoom:67%;></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h4>内置命令</h4><img src=./img/shell内部命令.png alt=shell内部命令 style=zoom:67%;></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h4>执行外部命令</h4><img src=./img/shell外部命令.png alt=shell外部命令 style=zoom:45%; width=40%></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class="content-center text-landing text-shadow"><h2>实现高速路网</h2></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h2>总流程图</h2><img src=./img/总流程图.png alt=总流程图 style=zoom:67%;></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h2>分工</h2><ul><li><h3>建图parse：高安程</h3></li><li><h3>最短路径solve1：邢玥茗</h3></li><li><h3>次短路径solve2：王天朔</h3></li><li><h3>调试：祁盛</h3></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h2>优化设计流程</h2></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h2>第一版建图</h2><hr><ul><li>每个有效节点通过<code>nodeCnt++</code>获得唯一的线性编号，不采用二维坐标</li><li>同行相邻的节点编号相邻</li><li>相邻行相邻的节点以第一行的列数（<code>maxLine</code>）作为跨行连接的 “基准”，推算编号（通过<code>nodeCnt - maxLine</code>等计算上一行节点）</li><li><strong>建边逻辑复杂，不直观</strong>：奇偶行的差异化规则增加了代码理解和维护成本，且需严格保证节点编号与行、列的对应关系（否则易出现连接错误）。</li></ul><img src=./img/image-20250714194429499.png alt=image-20250714194429499 style=zoom:80%;></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h2>第二版建图</h2><hr><ul><li><p>将节点编号改为二维的方式</p></li><li><p>优点：<strong>依照空间邻接关系来建模更为合理，更贴近真实场景</strong> ：</p><ul><li><p>边的建立不仅考虑同一行的左右相邻，还通过 “奇偶行差异化” 处理上下行的交错邻接，模拟了二维空间中节点的自然邻接关系（类似网格或蜂窝结构）</p><img src=./img/image-20250714194346705.png alt=image-20250714194346705 style="zoom: 80%;"></li></ul></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h2>Solve1流程图</h2><img src=./img/最短路径.png alt=最短路径 style=zoom:80%;></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h2>Solve1代码</h2><img src=./img/image-20250714194550356.png alt=image-20250714194550356 style=zoom:80%;></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h2>Solve2流程图</h2><img src=./img/次短路径.png alt=次短路径 style=zoom:67%;></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h2>Solve2代码</h2><img src=./img/image-20250714194630566.png alt=image-20250714194630566 style=zoom:67%;></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class="content-center text-landing text-shadow"><h2>黑白棋</h2></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h2>任务内容</h2><ul><li><h5>写出自己的AI与对方AI对战。</h5></li><li><h5>在经典黑白棋规则的基础之上，增加一个额外信息：棋子分数。对于棋盘上的每个格子，均有一个 1 至 9 之间的分数，格子上的分数属于格子上的棋子所属人。</h5></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h2>任务细节</h2><hr><ul><li><h3>任务一</h3><p>地图中所有格子除了中间四个以外均为1。</p></li><li><h3>任务二</h3><p>地图中所有格子除了中间四个<strong>四个角</strong>以外的分数均为1。</p></li><li><h3>任务三</h3><p>地图中所有格子除了<strong>中间四个以及最外层一圈</strong>以外的格子分数均为 1。</p></li><li><h3>任务四</h3><p>地图上的格子分数无额外限制。</p></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class="content-center text-landing text-shadow"><h2>具体实现</h2></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h2>代码内函数基本介绍</h2></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h3>一、初始化与工具函数</h3><ol><li><p><code>init(struct Player *player)</code></p><ul><li>功能：每局游戏开始时初始化 AI，调用<code>init_opponent</code>初始化对手走法优先级矩阵。</li></ul></li><li><p><code>init_opponent(struct Player *player)</code></p><ul><li>功能：初始化对手相关参数，记录初始棋子位置到<code>start_point</code>数组。</li></ul></li><li><p><code>copy_player(struct Player* dest, const struct Player* src)</code></p><ul><li>功能：深拷贝玩家状态（棋盘、分数、行列数等），用于假设性走棋时保存原状态。</li></ul></li><li><p><code>free_player_mat(struct Player* player)</code></p><ul><li>功能：释放玩家棋盘矩阵的动态内存，避免内存泄漏。</li></ul></li><li><p><code>in(struct Player *player,int x,int y)</code></p><ul><li>功能：判断坐标<code>(x,y)</code>是否在棋盘范围内。</li></ul></li></ol></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h3>二、合法性检查函数</h3><ol><li><p><code>is_valid(int row_cnt,int col_cnt,char mat[][30], int posx, int posy,char my_sign,char his_sign)</code></p><ul><li>功能：检查在指定棋盘<code>mat</code>中，<code>(posx,posy)</code>位置是否为<code>my_sign</code>的合法落子（能翻转<code>his_sign</code>的棋子）。</li></ul></li><li><p><code>is_avalid(struct Player *player, int posx, int posy)</code></p><ul><li>功能：检查当前玩家（己方，<code>'O'</code>）在<code>(posx,posy)</code>的落子是否合法（封装<code>is_valid</code>，固定己方为<code>'O'</code>，对手为<code>'o'</code>）。</li></ul></li><li><p><code>find_all_legal_moves(struct Player* player, struct Point legal_moves[])</code></p><ul><li>功能：查找当前玩家的所有合法落子，存储到<code>legal_moves</code>数组，返回合法走法数量。</li></ul></li><li><p><code>count_legal_moves(struct Player* player)</code></p><ul><li>功能：统计当前玩家的合法落子数量（行动力评估的基础）。</li></ul></li></ol></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h3>三、走法预测与选择函数</h3><ol><li><p><code>judge_corner(struct Player *player)</code></p><ul><li>功能：检查四个角落是否为己方合法落子，优先选择角落位置。</li></ul></li><li><p><code>judge_side(struct Player *player)</code></p><ul><li>功能：检查棋盘边缘（非角落）的合法落子，优先选择能巩固边缘控制的位置。</li></ul></li><li><p><code>calc_grade(struct Player *player)</code></p><ul><li>功能：计算每个合法落子的 “分数”（基于翻转对手棋子的数量和位置权重），用于排序。</li></ul></li><li><p><code>partition(int s,int t)</code>、<code>QuickSort(int s,int t)</code></p><ul><li>功能：快速排序算法，用于对合法落子按<code>calc_grade</code>计算的分数排序。</li></ul></li><li><p><code>select_point(struct Player *player)</code></p><ul><li>功能：从排序后的合法落子中选择最优位置，考虑稳定性、角落保护等策略。</li></ul></li><li><p><code>predict_opponent_move(struct Player *player)</code></p><ul><li>功能：预测对手的最佳落子位置（模拟对手视角的走法选择）。</li></ul></li></ol></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h3>四、棋盘状态处理函数</h3><ol><li><p><code>switch_perspective(struct Player* player)</code></p><ul><li>功能：切换棋盘视角（交换己方<code>'O'</code>和对手<code>'o'</code>的棋子，交换分数），用于模拟对手回合。</li></ul></li><li><p><code>make_hypothetical_move(struct Player* player, struct Point move)</code></p><ul><li>功能：在指定玩家的棋盘上执行假设性落子，并翻转所有被夹住的对手棋子（用于搜索时模拟走棋）。</li></ul></li><li><p><code>judge_stable(struct Player *player)</code></p><ul><li>功能：判断棋盘上的 “稳定棋子”（不会被对手翻转的棋子），标记到<code>map</code>数组中。</li></ul></li><li><p><code>exclude_position(struct Player *player,int x,int y)</code></p><ul><li>功能：判断<code>(x,y)</code>是否为需要排除的危险位置（可能导致对手抢占角落）。</li></ul></li><li><p><code>get_late_game_threshold(struct Player *player)</code></p><ul><li>功能：根据棋盘大小计算 “残局阈值”（棋子总数达到该值时，评估函数更侧重棋子数量）。</li></ul></li></ol></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h3>五、评估与搜索函数</h3><ol><li><p><code>evaluate_state(struct Player *player)</code></p><ul><li>功能：评估当前棋盘状态的分数，综合考虑角落控制、行动力、棋子数量（残局）三个因素，加权计算。</li></ul></li><li><p><code>compare_moves(const void *a, const void *b)</code></p><ul><li>功能：用于<code>qsort</code>的比较函数，按对手优先级降序排序合法走法，优化 Alpha-Beta 剪枝效率。</li></ul></li><li><p><code>alpha_beta(struct Player *player, int depth, int alpha, int beta, bool is_maximizing_player)</code></p><ul><li>功能：Alpha-Beta 剪枝搜索核心，递归评估各走法的优劣，返回最佳评估值（MAX 层最大化分数，MIN 层最小化分数）。</li></ul></li><li><p><code>place(struct Player *player)</code></p><ul><li>功能：AI 的核心落子决策函数，调用<code>alpha_beta</code>搜索选择最优落子位置，处理特殊情况（无合法走法或唯一走法）。</li></ul></li></ol></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class="content-center text-landing text-shadow"><h2>关键函数详细讲解</h2></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h3>1. <code>evaluate_state(struct Player *player)</code></h3><ul><li>评估当前棋盘状态的分数，综合考虑角落控制、行动力、棋子数量三个因素 <img src=./img/image-20250715170251148.png alt=image-20250715170251148 style=zoom:67%;></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h3><strong>关键点</strong>：</h3><ul><li><h5><strong>角落控制</strong>：角落位置（如<code>(0,0)</code>）对游戏胜负影响极大，得分为 ±1。</h5></li><li><h5><strong>行动力</strong>：当前可走步数多的一方更具优势，得分为<code>我方步数 - 对方步数</code>。</h5></li><li><h5><strong>残局策略</strong>：当棋子总数超过阈值（如 64 格棋盘为 37）时，转为重视棋子数量。</h5></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h5>2. <code>alpha_beta(struct Player *player, int depth, int alpha, int beta, bool is_maximizing_player)</code></h5><ul><li><p>Alpha-Beta 剪枝算法的核心实现，递归搜索最优走法，减少不必要的计算</p><img src=./img/image-20250715170500531.png alt=image-20250715170500531 style=zoom:67%;></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h3><strong>关键点</strong>：</h3><ul><li><h5><strong>剪枝优化</strong>：通过 Alpha（MAX 下限）和 Beta（MIN 上限）的比较，提前放弃不可能的分支</h5></li><li><h5><strong>递归搜索</strong>：交替模拟我方（MAX 层）和对手（MIN 层）的最优决策</h5></li><li><h5><strong>走法排序</strong>：使用<code>compare_moves</code>对走法预排序，提高剪枝效率</h5></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h3>3. <code>place(struct Player *player)</code></h3><ul><li><p>AI 的主决策函数，调用 Alpha-Beta 搜索选择最优落子位置</p><img src=./img/image-20250715170707557.png alt=image-20250715170707557 style=zoom:67%;></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h3><strong>关键点</strong>：</h3><ul><li><h5><strong>特殊情况处理</strong>：直接返回唯一走法或无合法走法。</h5></li><li><h5><strong>搜索深度</strong>：通过<code>SEARCH_DEPTH</code>（默认 4）控制递归层数，平衡计算效率和决策质量。</h5></li><li><h6><strong>走法评估</strong>：对每个合法走法生成假设棋盘，调用 Alpha-Beta 评估分数。</h6></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h3>4. <code>make_hypothetical_move(struct Player* player, struct Point move)</code></h3><ul><li><p>在假设棋盘上执行落子，并翻转被夹住的对手棋子</p><img src=./img/image-20250715170846644.png alt=image-20250715170846644 style=zoom:67%;></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h3><strong>关键点</strong>：</h3><ul><li><h5><strong>方向检测</strong>：检查 8 个方向上是否存在被夹住的对手棋子链。</h5></li><li><h5><strong>棋子翻转</strong>：从落子点出发，找到链的两端（己方棋子），将中间的对手棋子全部翻转。</h5></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h5>5. <code>is_valid(int row_cnt,int col_cnt,char mat[][30], int posx, int posy,char my_sign,char his_sign)</code></h5><ul><li><p>检查在指定位置落子是否合法（可翻转对手棋子)</p><img src=./img/image-20250715171030489.png alt=image-20250715171030489 style=zoom:67%;></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h3><strong>关键点</strong>：</h3><ul><li><h5><strong>边界检查</strong>：确保落子位置在棋盘内且为空。</h5></li><li><h5><strong>方向合法性</strong>：只要有一个方向能形成 “对手棋子链” 且链的末端是己方棋子，则合法。</h5></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h3>总结</h3><p>这些函数共同构成了一个完整的黑白棋 AI 决策系统：</p><ul><li><strong>评估函数</strong>（<code>evaluate_state</code>）提供局面价值判断，指导搜索方向。</li><li><strong>Alpha-Beta 剪枝</strong>（<code>alpha_beta</code>）通过递归搜索找到最优走法，优化计算效率。</li><li><strong>走法执行</strong>（<code>make_hypothetical_move</code>）和<strong>合法性检查</strong>（<code>is_valid</code>）确保 AI 的每一步都符合游戏规则。</li><li><strong>主决策函数</strong>（<code>place</code>）整合所有逻辑，输出最终落子位置。</li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h2>蒜头抢分大作战</h2></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h3>游戏简介</h3><p>在一个 <code>n x m</code> 的地图上，两只<strong>蒜头</strong>AI 对抗，争夺分数。地图上还有两名<strong>破坏者</strong>（鬼），它们会干扰并试图消灭蒜头。游戏目标是在回合结束时获得比对手更高的分数。</p><h3>核心规则</h3><h4>角色与地图</h4><ul><li>蒜头 共 2 只，玩家控制其中 1 只。</li><li>破坏者 共 2 只，AI 控制。其移动有随机性，但会优先追击距离更近的蒜头。</li><li>地图<ul><li>墙 无法进入。</li><li>地面 可以移动，地面上可能有 <strong>普通星</strong> 或 <strong>超级星</strong>。</li></ul></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h3>任务与策略</h3><h4>任务一：静态环境</h4><ul><li><strong>场景</strong> 10×10 地图，对手 AI 和破坏者均<strong>不动</strong>。</li><li><strong>目标</strong> &gt; 500 分。</li><li><strong>核心策略</strong> 由于所有单位静止，此任务可简化为寻路问题。只需规划一条<strong>最短路径</strong>，吃掉地图上所有星星，同时避开固定的对手和墙壁即可。</li></ul><h3>任务二：动态环境</h3><ul><li><p><strong>场景</strong> 10×10 地图，对手 AI 不动，但有 1-2 名<strong>移动的破坏者</strong>。</p></li><li><p><strong>目标</strong> &gt; 500 分 (单鬼) / &gt; 400 分 (双鬼)。</p></li><li><p><strong>核心策略</strong> 高分的关键在于<strong>利用强化状态吃掉破坏者</strong>。</p></li><li><p><strong>基本思路</strong></p><ol><li><strong>生存优先</strong> 普通状态下，计算与破坏者的距离，保持安全距离，避免被捕。</li><li><strong>寻找超级星</strong> 将吃<strong>超级星</strong>作为首要目标，以进入可以反击的强化状态。</li><li><strong>主动出击</strong> 进入强化状态后，立刻改变策略，<strong>主动追击</strong>破坏者来获取高额分数。</li><li><strong>机会主义</strong> 在确保安全或追击破坏者的途中，顺路收集普通星星。</li></ol></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h2>任务三&amp;四&amp;PVP思路</h2></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><ol><li>13 * 15 有迷宫地图，双鬼不动，ai动 实验一下就会发现ai很傻，根本不可能吃到超级星（即甚至不用考虑躲避对手），也不可能依赖吃对手大幅度提升自己的分数，所以采取自力更生策略</li></ol><p>策略：专注 “逐行吃豆”，<strong>高效清理所有豆子</strong>，完全不考虑与幽灵或对手的互动：</p><ul><li>遍历顺序：从地图最下行开始，逐行向上清理（<code>row从row_cnt-1递减到0</code>）。</li><li>每行处理：统计当前行所有剩余豆子（<code>'o'</code>或<code>'O'</code>），对每个豆子，计算从玩家当前位置向四个方向移动后到该豆子的最短距离，选择距离最小的方向。</li><li>优先级：只要当前行有豆子，就优先吃本行，直到本行豆子吃完再处理上一行；所有豆子吃完后原地不动。</li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><ol start=2><li>10 * 10 全豆地图，双鬼和随机ai都动 <strong>玩家处于 “普通状态”（需规避幽灵，优先吃豆）</strong><br>此时按 “超级豆<code>'O'</code>优先于普通豆<code>'o'</code>” 的逻辑决策，通过<strong>评分机制</strong>平衡 “安全性” 和 “吃豆效率”：</li></ol><ul><li><p>若存在超级豆（<code>nowstar &gt; 0</code>）：<br>对四个方向的潜在移动计算评分<code>tjudge</code> <code>tjudge = (30 - nowghost) * (tghost - nowghost) + 27 * (nowstar - tstar)</code> nowghost为当前位置距离幽灵的最短距离，tghost为尝试移动后距离幽灵的最短距离 nowstar为当前位置距离超级星的最短距离，tstar为尝试移动后距离超级星的最短距离</p><ul><li>第一项：鼓励 “移动后与幽灵的距离变大”（<code>tghost - nowghost</code>为正，更安全），权重与当前幽灵距离负相关（幽灵越近，越重视安全性）。</li><li>第二项：鼓励 “移动后与超级豆的距离变小”（<code>nowstar - tstar</code>为正，更快吃到），权重固定为 27。</li><li>规避危险：若移动后与幽灵距离为 1（即时危险），评分为负无穷，直接排除。</li></ul></li><li><p><strong>若没有超级豆（优先普通豆）</strong>：<br>逻辑类似，但评分公式调整为：<br><code>tjudge = (100 - nowghost) * (tghost - nowghost) + 97 * (nowlstar - tlstar)</code></p><ul><li>普通豆的权重（97）远高于超级豆场景，更侧重高效吃普通豆；</li><li>对幽灵距离的敏感度降低（系数从 30 变为 100），允许在更安全的情况下优先吃豆。</li></ul></li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h2>任务四</h2><p>鬼和ai都动，且ai有一定判断能力 这个四个人的思路就很不同了</p></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h3>gac：</h3><h3>qs：延续任务二的堵门流（刷分方法）</h3><h3>wts：</h3></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-LEFT><h4>一、死胡同判断的优化：精准识别高风险地形</h4><p>通过<code>is_dead_end</code>函数判断：</p><ol><li><strong>基于 “有效出口数量” 的判断逻辑</strong><br>函数通过统计目标位置（x,y）的<strong>4 个正交方向（上下左右）的有效出口</strong>（非墙且在地图内）数量，若有效出口≤1，则判定为死胡同。</li><li><strong>与风险评估联动</strong><br>死胡同判断结果（<code>is_dead_end</code>）会直接影响星星的综合评分：在<code>calculate_star_score</code>中，若星星位于死胡同且幽灵距离＜安全阈值（<code>DEAD_END_SAFE_DIST=5</code>），会额外扣除 300 分（惩罚高风险死胡同）。<ul><li>区分 “安全死胡同”（幽灵距离≥5）和 “危险死胡同”（幽灵距离＜5），避免盲目进入高风险狭窄区域，平衡 “吃豆收益” 与 “逃生难度”。</li></ul></li></ol></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-left><h4>二、安全距离阈值的优化：分层适配场景风险</h4><p>安全距离阈值是判断 “威胁程度” 的核心参数，代码通过<strong>分层设置阈值</strong>，适配不同场景的风险特性，优化点如下：</p><ol><li><strong>基础安全距离（<code>SAFE_DISTANCE=1</code>）</strong><br>定义 “与幽灵 / 强化对手的最小安全距离”：曼哈顿距离＞1（即不相邻）。若距离≤1，判定为 “即时危险”（例如幽灵在隔壁格子，下一步可能被攻击）。</li><li><strong>危险预警距离（<code>DANGER_DISTANCE=3</code>）</strong><br>当幽灵距离≤3 时，触发 “主动躲避逻辑”（调用<code>find_best_move_away_ghost</code>）。</li><li><strong>死胡同专属安全距离（<code>DEAD_END_SAFE_DIST=5</code>）</strong><br>针对死胡同（逃生路径少）设置更远的安全距离：只有当幽灵距离≥5 时，才认为死胡同内的豆子 “相对安全”。这个5相当于设置了更远的安全距离补偿其 “路径单一” 的风险，避免在狭窄通道中被幽灵前后夹夹击</li></ol></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-LEFT><h4>三、幽灵预测的优化：动态趋势预判，减少决策滞后</h4><p>幽灵的移动具有一定连续性，代码通过<code>predict_ghost_pos</code>函数预测其下一步位置，优化点如下：</p><ol><li><strong>基于 “历史移动趋势” 的预测逻辑</strong><br>利用幽灵 “沿直线移动” 的特性（多数 AI 控制的幽灵倾向于保持方向）。通过记录幽灵的 “上一位置” 和 “当前位置”，预测下一位置为 “当前位置 + 方向向量”；若预测位置是墙或越界，则保持当前位置。</li><li><strong>适配攻击与躲避决策</strong><br>预测位置用于后续的 “攻击目标评估”（<code>AttackTarget</code>）：计算与预测位置的距离、性价比（奖励 / 距离），优先追击 “易击杀（距离近、奖励高）” 的幽灵。</li></ol></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-LEFT><h3>xym：</h3><h4>移动方向选择：基于加权评分的精细化决策</h4><p>在 “接近目标” 或 “远离威胁” 时，通过<strong>加权评分机制</strong>量化每个方向的优劣，选择最优解：</p><ol><li><strong>接近目标（<code>find_best_move_approach</code>）</strong><br>遍历四个方向（+ 不动），选择 “移动后到目标距离最短” 的方向，确保高效接近目标（幽灵、豆子等）。</li><li><strong>远离幽灵（<code>find_best_move_away_ghost</code>）</strong><br>对每个候选方向评分，核心权重包括：<ul><li>规避 3 步内的幽灵（权重<code>W1=10000</code>，距离越近惩罚越大）；</li><li>不进入另一个幽灵的 3 步内（权重<code>W2=5000</code>）；</li><li>靠近超级豆（权重<code>W4=2000</code>，距离越近加分越多）；</li><li>优先吃普通豆（权重<code>W5=1000</code>）；</li><li>拉长与两个幽灵的距离（权重<code>W6=2</code>，用距离平方和放大长距离优势）；</li><li><strong>规避墙边和普通胡同（减少被堵风险）。</strong></li></ul></li><li><strong>远离对手（<code>find_best_move_away_opponent</code>）</strong><br>逻辑类似远离幽灵，但更侧重 “拉大与对手的距离”（用距离平方放大优势）和规避普通胡同。</li></ol></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-LEFT><h4>胡同环境的特殊处理</h4><p>胡同作为高风险狭窄区域，单独设计了逃生策略：</p><ul><li><strong>胡同内逃生（<code>escape_in_alley</code>）</strong>：当处于胡同中且被幽灵逼近时，仅沿胡同的两个可通行方向移动，选择 “到幽灵距离最远” 的方向（避免在狭长通道中被前后夹击）。</li><li><strong>超级豆胡同动态更新</strong>：当超级豆被吃掉后，通过<code>update_alley_after_eat_superstar</code>将 “超级星胡同” 降级为普通胡同，避免后续错误决策（无需再向该胡同移动）。</li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h2>PVP</h2></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-LEFT><h3>一、策略的动态适应性：基于地图规模的分层调整</h3><p><strong>根据地图大小（面积）动态切换策略参数</strong>，将地图分为四类::</p><ul><li><strong>小地图（面积≤120）</strong>：激进策略。 高攻击权重（5.0）、低抢占阈值（1）、低开阔度奖励（15.0），倾向于主动竞争豆子和攻击。</li><li><strong>中地图（120 &lt; 面积≤250）</strong>： 均衡策略。中等攻击权重（2.0）、中等抢占阈值（0）、中等开阔度奖励（20.0），平衡得分与安全。</li><li><strong>大地图（250 &lt; 面积≤400）</strong>： 保守策略。低攻击权重（0.8）、负抢占阈值（-5）、高开阔度奖励（30.0），更注重安全和规避风险。</li><li><strong>超大地图（面积 &gt; 400）</strong>： 生存优先策略。极低攻击权重（0.2）、极低抢占阈值（-10）、极高开阔度奖励（50.0），核心目标是存活，优先选择安全区域。</li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-LEFT><h3>二、核心决策逻辑：状态优先</h3><hr><h4>1. 强化状态下（自身处于可攻击状态）：优先攻击</h4><p>强化状态（可能是吃超级豆后获得，有时间限制）下，行为核心是<strong>利用攻击窗口期获取收益</strong>：</p><ul><li>攻击目标包括两类：<ul><li>幽灵：若与幽灵的距离小于强化剩余时间（可追上并击杀），优先攻击（得分高）。</li><li>对手：若对手未处于强化状态，且距离小于强化剩余时间（可攻击），则作为备选目标。</li></ul></li><li>攻击目标的优先级通过 “距离倒数 × 攻击权重” 评估：距离越近、攻击权重越高（小地图），优先级越高。</li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-LEFT><h4>2. 非强化状态下：优先收集豆子（兼顾安全）</h4><p>非强化状态下，核心是<strong>安全收集豆子得分</strong>，豆子评估综合多维度因素：</p><ul><li><strong>超级豆优先</strong>：优先选择 “自身距离≤对手距离 + 抢占阈值” 的超级豆（确保能抢到手），超级豆可触发强化状态，是扭转局势的关键。</li><li><strong>普通豆评估</strong>：对普通豆计算综合得分，公式为：<br><code>得分 = -距离惩罚（距离越近越好） - 幽灵风险惩罚（幽灵越近风险越高） + 开阔度奖励（出口越多越安全）</code><br>其中，幽灵风险根据距离分级（≤1 格风险 + 100，≤3 格风险 + 60），避免靠近危险区域；开阔度（出口数量）影响安全，高开阔度位置更易躲避，在大图中权重更高。</li><li><strong>规避死胡同</strong>：死胡同仅在距离幽灵足够远时才考虑，避免被困。</li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-LEFT><h4>3. 无明确目标或危险时：优先安全移动</h4><p>当没有合适的攻击目标或豆子（如所有豆子风险过高），则通过<code>find_safe_adjacent</code>寻找最安全的相邻位置：</p><ul><li>安全评估标准：到幽灵 / 对手的距离（越远越安全）+ 开阔度（越高越安全），确保不进入危险区域（幽灵 / 对手的安全距离内）。</li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-LEFT><h3>三、风险控制机制</h3><p>策略中嵌入多重安全保障，确保生存底线：</p><ul><li><strong>路径安全性检查</strong>：所有移动前通过<code>is_valid_move</code>验证，避免进入幽灵 / 对手的安全距离内（非强化状态）。</li><li><strong>BFS 路径规划</strong>：通过 BFS 计算最短路径，确保移动高效且安全（只走可达且无即时危险的路线）</li><li><strong>紧急避险</strong>：若目标路径不安全，立即切换到<code>find_safe_adjacent</code>返回的安全位置，避免死亡。</li><li><strong>初始安全点</strong>：初始化时计算 “离两个幽灵总距离最远” 的位置，作为潜在避难所。</li></ul></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h1>提问</h1></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-center><h2>感谢各位助教老师的工作！辛苦啦！</h2></div></div></section></article></div><script src=https://cdn.staticfile.org/echarts/4.8.0/echarts.min.js></script><script src=https://cdn.staticfile.org/mermaid/8.5.2/mermaid.min.js></script><script>mermaid.startOnLoad = false;</script><script>window.pluginsOptions = {}



    window.webslidesOptions = {}


document.addEventListener('DOMContentLoaded', () => {
    let isPrintMode = false;
    if(~location.search.indexOf('print-pdf')){
        isPrintMode = true;
        WebSlides.registerPlugin('scroll', function(){});
    }
    const wsOptions = {
        loop: false
    };
    if(window.webslidesOptions){
        for (let i in webslidesOptions){
            if(webslidesOptions.hasOwnProperty(i)){
                wsOptions[i] = webslidesOptions[i];
            }
        }
    }
    const ws = new WebSlides(wsOptions)

    window.wsInstance = ws;
    if(isPrintMode){
        ws.slides.forEach(s=>s.show())
    }
}, false)</script><script src=./js/chunk-vendors.js></script><script src=./js/slide.js></script></body></html>